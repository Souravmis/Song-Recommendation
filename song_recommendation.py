# -*- coding: utf-8 -*-
"""Song_Recommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t6i4he2x-UhY-mSFWtfRE6I8HnI4wEeK
"""

import pandas as pd
import numpy as np
# import matplotlib.pyplot as plt



"""Here we are going to use listen_count, the number of times a user listened to a song as an implicit rating"""

"""## Most popular songs"""


"""## Popularity based recommendation system:"""

class Recommend_by_popularity():

    def __init__(self):
      self.data = None
      self.user_id = None
      self.song = None
      self.popularity_recommendations = None


    def fit(self, data, user_id, song):
      self.data = data
      self.user_id = user_id
      self.song = song
      #self.popularity_recommendations = None

      data_grouped = data.groupby([self.song]).agg({self.user_id: 'count'}).reset_index()
      data_grouped.rename(columns={'user_id':"count"}, inplace = True)
      data_grouped.sort_values(by = 'count' , ascending =False, inplace = True)
      
      #Generate a recommendation rank based upon score
      data_grouped['Rank'] = data_grouped['count'].rank(ascending=0, method='first')
      self.popularity_recommendations = data_grouped.head(10)

    def recommend(self, user_id):
        user_recommendations = self.popularity_recommendations

        user_recommendations['user_id'] = user_id

        cols = user_recommendations.columns.tolist()
        cols = cols[-1:] + cols[:-1]
        user_recommendations = user_recommendations[cols]
        
        return user_recommendations



"""##Colaberative filtering

We require a sparse matrix of user X item
"""

from  scipy.sparse import csr_matrix

# we will use the function pivot to produce the pivot table then we'll convert this table to sparse matrix


# which is a sparse matrix of shape (number of unique songs X number of unique users) i.e item X user matrix


"""There are two techniques to perform colaberative filtering 
  
  1. User based approach- It finds users with similar interests and beahaviour, and considering what those similar users listened to, it makes a recommendation. This technique is also known as user-item CF.

  2. Item based approach- It take into account what songs the user has considered in the past and recommend new similar songs that the user can enjoy. This technique is also know as item-item CF. 

"""


"""##Colaberative filtering with Nearest Neighbors:"""

# Lets go with nearest neighbor algorithm to recommend songs.
from sklearn.neighbors import NearestNeighbors
from fuzzywuzzy import fuzz

class Recommend_by_neighbors():
  def __init__(self, metric, algorithm, k, data, decode_id_song):
    self.metric = metric
    self.algorithm = algorithm
    self.k = k
    self.decode_id_song = decode_id_song
    # p = list(self.decode_id_song.values())
    self.data = data
    self.model = self._recommender().fit(data)

  def _recommender(self):
    return NearestNeighbors(metric = self.metric, algorithm = self.algorithm, n_neighbors = self.k)

  def make_recommendation(self, new_song, n_recommendations = 10):
    rec_song_id = self._fuzzy_matching(song = new_song)
    if rec_song_id!='error':
      distances, indices = self.model.kneighbors(self.data[rec_song_id], n_neighbors = n_recommendations)
    # indices = self._map_indices_to_song_title(indices)
      return sorted(list(zip(self._map_indices_to_song_title(indices.squeeze().tolist()), distances.squeeze().tolist())), key = lambda x: x[1])
    else:
      return "404"

  def _map_indices_to_song_title(self, recommendation_ids ):
    values = []
    for id in recommendation_ids:
      values.append({song_id: song_title for song_title, song_id in self.decode_id_song.items()}[id])
    return values
  
  def _fuzzy_matching(self, song):
    match_tuple = []
    count = 0
    for title, idx in self.decode_id_song.items():
      ratio = fuzz.ratio(title.lower(), song.lower())
      if ratio>=60:
        count+=1
        match_tuple.append((title, idx, ratio))
    if count>0:
      match_tuple = sorted(match_tuple, key = lambda x: x[2])[::-1]
      return match_tuple[0][1]
    else:
      return 'error'
    

# df_unique_songs = df_song_more_ten['song_id'].unique()
# df_unique_songs = pd.DataFrame(df_unique_songs)


